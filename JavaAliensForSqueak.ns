Newspeak3
'JavaAliens'
class JavaAliensForSqueak usingPlatform: platform usingJNILibrary: jni = (
(* Java FFI built using JNI and Newspeak Aliens FFI. *)|
	Alien = platform aliens Alien.
	List = platform collections List.
	jni = jni.
	private theRuntime
	private theJavaAliens
|) (
private class AlienHelpers = (
(* Mainly Pointer Alien manipulation. Ideally this will go away. *)||) (
) : (
public coerce: argList <JavaAlien | Collection[JavaAlien]> = (
	(* 	Coerce is necessary so long as JavaAlien is not an Alien.
		This function should still work if JavaAlien becomes an Alien, because Alien asAlien returns self.	*)

	^argList isCollection
		ifTrue: [argList collect: [:arg | arg asAlien]]
		ifFalse: [argList asAlien].
)
public cstring: string = (
	^Alien forPointer: (string asAlien address).
)
public isNullPtr: pointerAlien = (
	^pointerAlien address = 0
)
public nullPtr = (
	^Alien forPointer: 0.
)
public safePtr: pointerAlien = (
	^(isNullPtr: pointerAlien) ifTrue: [nil] ifFalse: [pointerAlien]
)
)
class GetFieldTypeTranslator = TypeTranslator (|
|) (
public field: fieldName = (
	| invocation |
	invocation:: translateField: fieldName.
	^invocation isNil
		ifTrue: [super doesNotUnderstand]
		ifFalse: [invocation value]
)
public field: fieldName sig: sig = (
	| invocation |
	invocation:: translateField: fieldName sig: sig.
	^invocation isNil
		ifTrue: [super doesNotUnderstand]
		ifFalse: [invocation value]
)
public translateField: fieldName = (
	subclassResponsibility
)
public translateField: fieldName sig: sig = (
	^subclassResponsibility
)
) : (
)
private class JavaAliens usingJNIEnv: env = (
(* All JavaAlien instances have access to a JNIEnv library through this module. *)|
	env = env.
|) (
class JavaAlien on: anAlien = Struct on: anAlien (| env |) (
) : (
)
public class JavaArray jarray: jarray = (
(* Encapsulates a jarray(jobject) pointer and invokes jarray-oriented api calls. *)|
	jarray = jarray.
|) (
public asAlien = (
	^jarray
)
public getElement: index = (
	(* Currently assuming the object is a String *)
	| jobject |
	jobject:: env GetObjectArrayElement: jarray index: index.
	^(isNullPtr: jobject)
		ifTrue: [nil]
		ifFalse: [String jstring: jobject].
)
public setElements: values = (
	| index |
	index:: 0.
	values do: [:eachValue |
		| valuePointer |
		valuePointer:: eachValue asAlien.
		env SetObjectArrayElement: jarray index: index value: valuePointer.
		index:: index + 1
	]
)
) : (
public emptyOf: elementClass = (
	^self of: elementClass size: 0
)
public of: elementClass size: size = (
	| jarray |
	jarray:: env NewObjectArray: size elementClass: (elementClass asAlien) initialElement: help nullPtr.
	^(jarray address = 0) ifFalse: [JavaArray jarray: jarray] ifTrue: [couldNotCreateArray. nil]
)
public of: elementClass values: values = (
	| arrayObject |
	arrayObject:: self of: elementClass size: (values size).
	arrayObject setElements: values.
	^arrayObject.
)
)
public class JavaClass jclass: jclass = (
(*Encapsulates a jclass pointer and invokes jclass-oriented api calls, notably static method api calls.*)|
	jclass = jclass.
	callTranslator = CallStaticMethodTypeTranslator new.
	getTranslator = GetStaticFieldTypeTranslator new.
	setTranslator = SetStaticFieldTypeTranslator new.
|) (
private class CallStaticMethodTypeTranslator = MethodTypeTranslator (
(* Attempts to relay messages through method invokation. *)|
|) (
protected returnSignature: methodSignature = (
	^(methodSignature subStrings: ')') at: 2
)
public translateMethod: staticMethodName args: args = (
	^unimplemented.
)
public translateMethod: staticMethodName argsTypes: argTypes = (
	^unimplemented.
)
public translateMethod: staticMethodName numArgs: numArgs = (
	unimplemented.
)
public translateMethod: staticMethodName sig: sig = (
	| methodID type |
	methodID:: env GetStaticMethodID: jclass name: (help cstring: staticMethodName) sig: (help cstring: sig).
	(help isNullPtr: methodID) ifTrue: [^StaticMethodNotFound].

	type:: returnType: (returnSignature: sig).
	^[:finalArgs | invokeCallStaticTypeMethod: type methodID: methodID args: finalArgs].
	)
) : (
)
private class GetStaticFieldTypeTranslator = GetFieldTypeTranslator (|
|) (
public translateField: staticFieldName = (
	unimplemented.
)
public translateField: staticFieldName sig: sig = (
	| fieldID type |
	fieldID:: env GetStaticFieldID: jclass name: (help cstring: staticFieldName) sig: (help cstring: sig).
	(help isNullPtr: fieldID) ifTrue: [^StaticFieldNotFound].

	type:: returnType: sig.
	^[invokeGetStaticTypeField: type fieldID: fieldID].
)
) : (
)
private class SetStaticFieldTypeTranslator = SetFieldTypeTranslator (|
|) (
public translateField: staticFieldName = (
	unimplemented.
)
public translateField: staticFieldName sig: sig = (
	| fieldID type |
	fieldID:: env GetStaticFieldID: jclass name: (help cstring: staticFieldName) sig: (help cstring: sig).
	(help isNullPtr: fieldID) ifTrue: [^StaticFieldNotFound].

	type:: returnType: sig.
	^[:value | invokeSetStaticTypeField: type fieldID: fieldID value: value ].
)
) : (
)
public asAlien = (
	^jclass.
)
public call = (
	^callTranslator
)
public get = (
	^getTranslator.
)
invokeCallStaticTypeMethod: returnType methodID: methodID args: args <Collection> = (
	^env CallStaticTypeMethod: returnType clazz: jclass methodID: methodID withArguments: args.
)
invokeGetStaticTypeField: returnType fieldID: fieldID = (
	^env GetStaticTypeField: returnType clazz: jclass fieldID: fieldID.
)
invokeSetStaticTypeField: returnType fieldID: fieldID value: value = (
	^env SetStaticTypeField: returnType clazz: jclass fieldID: fieldID value: value.
)
public set = (
	^SetStaticFieldTypeTranslator
)
) : (
public find: name = (
	| jclass |
	jclass:: env FindClass: (name asAlien address).
	^(help isNullPtr: jclass)
		ifTrue: [nil]
		ifFalse: [JavaClass jclass: jclass].
)
)
public class JavaString jstring: jstring = (|
	jstring = jstring.
|) (
public asAlien = (
	^jstring
)
public stringValue = (
	| cstring |
	cstring:: env GetStringUTFChars: jstring isCopy: nullPtr.
	^cstring strcpy.
)
) : (
public from: nsString = (
	| jstring |
	jstring:: (env NewStringUTF: (help cstring: nsString)).
	^(jstring address = 0)
		ifTrue: [CouldNotCreateString. nil.]
		ifFalse: [JavaString jstring: jstring.]
)
)
) : (
)
protected class MethodTypeTranslator = TypeTranslator (|
|) (
public method: methodName = (
	^method: methodName args: (List new).
)
public method: staticMethodName arg: arg = (
	^method: staticMethodName args: (List with: arg).
)
public method: staticMethodName args: args = (
	| invocation nativeArgs |
	nativeArgs:: help coerce: args.
	invocation:: translateMethod: staticMethodName args: nativeArgs.
	^invocation isNil
		ifTrue: [super doesNotUnderstand]
		ifFalse: [invocation value: nativeArgs]
)
public method: staticMethodName sig: sig = (
	^method: staticMethodName sig: sig args: (List new).
)
public method: staticMethodName sig: sig arg: arg = (
	^method: staticMethodName sig: sig args: (List with: arg)
)
public method: staticMethodName sig: sig args: args = (
	| invocation nativeArgs |
	nativeArgs:: help coerce: args.
	invocation:: translateMethod: staticMethodName sig: sig.
	^invocation isNil
		ifTrue: [super doesNotUnderstand]
		ifFalse: [invocation value: nativeArgs]
)
public translateMethod: methodName numArgs: numArgs = (
	subclassResponsibility.
)
public translateMethod: methodName sig: sig = (
	subclassResponsibility
)
) : (
)
private class Runtime classpath: classpath = (
(* Encapsulates JVM and access to the classpath. Holds jvm and env pointers required for all interactions with Java. *)|
	public jvm	
	public env
	public running
	public preexisting 
|init: classpath) (
private createVM: classpath = (
	| options initArgs jvmPtrBuffer envPtrBuffer result success |

	options:: jni JavaVMOption newC.
	options optionString: (('-Djava.class.path=', classpath) asAlien address).
	
	initArgs:: jni JavaVMInitArgs newC.
	initArgs version: (jni VERSION_1_2).
	initArgs nOptions: 1.
	initArgs options: (options address).
	initArgs ignoreUnrecognized = (jni FALSE).

	(* 	envPtr is equivalent to JNIEnv* env;
		*env (i.e. the data pointed to by envPtr is itself the address of the JNINativeInterface struct	*)
	jvmPtrBuffer:: Alien newC: 4.
	envPtrBuffer:: Alien newC: 4.

	result:: jni CreateJavaVM: (jvmPtrBuffer address) p_env: (envPtrBuffer address) vm_args: (initArgs address).

	result = (jni OK)
	ifTrue: [
		jvm:: jni JavaVM withVmPtr: (derefPtrPtr: jvmPtrBuffer).
		env:: jni JNIEnv withEnvPtr: (derefPtrPtr: envPtrBuffer).
	].

	^result = (jni OK)
)
private derefPtrPtr: pointerPointerAlien = (
	^jni derefPtrPtr: pointerPointerAlien
)
private destroyVM = (
	^jvm DestroyJavaVM
)
public getClass: name = (
	| jclass |
	jclass:: env FindClass: (name asAlien address).
	^(help isNullPtr: jclass)
		ifTrue: [nil]
		ifFalse: [JavaClass jclass: jclass].
)
private init: classpath = (
	loadExistingVM ifTrue: [
		preexisting:: true. 
		running:: true
	] ifFalse: [
		preexisting:: false.
		(createVM: classpath) ifTrue: [
			running:: true
		] ifFalse: [
			running:: false.
			couldNotStartVM.
		]
	]
)
private loadEnvFromVM: jvmInst = (
	| envPtrBuffer result |
	envPtrBuffer:: Alien newC: 4.
	result:: Alien new: 4.

	result:: jvmInst GetEnv: (envPtrBuffer address) version: (jni VERSION_1_2).
	result = (jni OK) ifTrue: [env:: jni JNIEnv withEnvPtr: (derefPtrPtr: envPtrBuffer)].
	^result
)
private loadExistingVM = (
	| jvmPtrBuffer jvmInst nVMsBuffer numVMs result |
	jvmPtrBuffer:: Alien newC: 4.
	nVMsBuffer:: Alien newC: 4.
	
	result:: jni GetCreatedJavaVMs: (jvmPtrBuffer address) bufLen: 1 nVMs: (nVMsBuffer address).
	result = (jni OK) ifFalse: [^false].

	numVMs:: nVMsBuffer unsignedLongAt: 1.
	numVMs = 1 ifFalse: [^false]. (* Would always be 0 or 1 in modern JNI *)

	jvmInst:: jni JavaVM withVmPtr: (derefPtrPtr: jvmPtrBuffer).
	result:: loadEnvFromVM: jvmInst.
	result = (jni OK) ifTrue: [jvm:: jvmInst].
	
	^result = (jni OK)
)
private recreateVM = (
	(* 	THIS MAY NEVER WORK
		JDK-4712793 : JNI : Failure in JNI_CreateJavaVM() after calling DestroyJavaVM()
		http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4712793	*)
	| result |

	result:: loadExistingVM.
	result = (jni OK) ifFalse: [^false].

	result:: destroyVM.
	result = (jni OK) ifFalse: [^false].

	^createVM
)
) : (
)
class SetFieldTypeTranslator = TypeTranslator (|
|) (
public field: fieldName sig: sig to: value = (
	| invocation nativeValue |
	nativeValue:: help coerce: value.
	invocation:: translateField: fieldName sig: sig.
	^invocation isNil
		ifTrue: [super doesNotUnderstand]
		ifFalse: [invocation value: nativeValue]
)
public field: fieldName to: value = (
	| invocation nativeValue |
	nativeValue:: help coerce: value.
	invocation:: translateField: fieldName.
	^invocation isNil
		ifTrue: [super doesNotUnderstand]
		ifFalse: [invocation value: nativeValue]
)
public translateField: fieldName = (
	subclassResponsibility
)
public translateField: fieldName sig: sig = (
	^subclassResponsibility
)
) : (
)
class TypeTranslator = (|
|) (
protected dontPackage = (
	^[:input | input]
)
protected returnType: returnSignature = (
	(* Can/should we query JNI for the return type instead of examining the signature? *)

	returnSignature = 'V' ifTrue: [^env returnType void packager: dontPackage].
	(returnSignature at: 1) = "L" ifTrue: [^env returnType jobject packager: dontPackage].
	returnSignature = 'Z' ifTrue: [^env returnType jboolean packager: dontPackage].
	returnSignature = 'I' ifTrue: [^env returnType jint packager: dontPackage].
	returnSignature = 'D' ifTrue: [^env returnType jdouble packager: dontPackage].
	returnSignature = 'J' ifTrue: [^env returnType jlong packager: dontPackage].
	returnSignature = 'B' ifTrue: [^env returnType jbyte packager: dontPackage].
	returnSignature = 'F' ifTrue: [^env returnType jfloat packager: dontPackage].
	returnSignature = 'C' ifTrue: [^env returnType jchar packager: dontPackage].
	returnSignature = 'S' ifTrue: [^env returnType jshort packager: dontPackage].
	
	^nil
)
) : (
)
public JavaArray = (
	^javaAliens JavaArray
)
public JavaClass = (
	^javaAliens JavaClass
)
public JavaString = (
	^javaAliens JavaString
)
private defaultClasspath = (
	^'.'
)
public env = (
	^runtime env.
)
protected help = (
	^AlienHelpers
)
private javaAliens = (
	theJavaAliens isNil ifTrue: [loadRuntime: defaultClasspath].
	^theJavaAliens
)
public loadClasspath: classpath = (
	^loadClasspath: classpath ifAlreadyLoaded: [self]
)
public loadClasspath: classpath ifAlreadyLoaded: exec = (
	theRuntime isNil ifTrue: [
		loadRuntime: classpath.
		theRuntime preexisting ifTrue: [
			^exec value
		].
	] ifFalse: [
		^exec value.
	].
)
private loadRuntime: classpath = (
	| aRuntime |
	aRuntime:: Runtime classpath: classpath.
	aRuntime running ifFalse: [couldNotLoadRuntime].

	theRuntime:: aRuntime.
	theJavaAliens:: JavaAliens usingJNIEnv: (theRuntime env).
)
public runApplication: mainClassName = (
	| mainClass stringClass |
	(* For now this is passing an empty String array *)
	stringClass:: runtime getClass: 'java/lang/String'.
	^runApplication: mainClassName argsArray: (Array emptyOf: stringClass)
)
public runApplication: mainClassName  args: args <Collection> = (
	| stringClass argStringObjects |
	(* For now this is passing an empty String array *)
	stringClass:: runtime getClass: 'java/lang/String'.
	argStringObjects:: args collect: [:eachArg | JavaString from: eachArg].
	^runApplication: mainClassName argsArray: (JavaArray of: stringClass values: argStringObjects)
)
private runApplication: mainClassName argsArray: argsArray = (
	| mainClass |
	mainClass:: runtime getClass: mainClassName.
	mainClass call method: 'main' sig: '([Ljava/lang/String;)V' arg: argsArray.
)
private runtime = (
	theRuntime isNil ifTrue: [loadRuntime: defaultClasspath].
	^theRuntime.
)
) : (
)
