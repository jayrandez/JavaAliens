Newspeak3
'Java'
class JNILibrary usingPlatform: platform = (
(*Bindings for Java Native Interface via Aliens FFI *)|
	Alien = platform aliens Alien.
	private definitions = Definitions new.
	private structures = Structures new.
|) (
private class Definitions = (||) (
public ABORT = (
	^2
)
public COMMIT = (
	^1
)
public EDETACHED = (
	(* thread detached from the VM *)
	^-2
)
public EEXIST = (
	(* VM already created *)
	^-5
)
public EINVAL = (
	(* invalid arguments *)
	^-6
)
public ENOMEM = (
	(* not enough memory *)
	^-4
)
public ERR = (
	(* unknown error *)
	^-1
)
public EVERSION = (
	(* JNI version error *)
	^-3
)
public FALSE = (
	^0
)
public OK = (
	(* success *)
	^0
)
public TRUE = (
	^1
)
public VERSION_1_1 = (
	^65537 (*0x00010001*)
)
public VERSION_1_2 = (
	^65538 (*0x00010002*)
)
public VERSION_1_4 = (
	^65540 (*0x00010004*)
)
public VERSION_1_6 = (
	^65542 (*0x00010006*)
)
public VERSION_1_8 = (
	^65544 (*0x00010008*)
)
) : (
)
public class JNIEnv withEnvPtr: envPointerAlien = (
(* Encapsulates standard env methods. Function pointers provided by struct JNINativeInterface. *)|
	env = envPointerAlien.
	api = struct JNINativeInterface on: (Alien forPointer: (envPointerAlien unsignedLongAt: 1)).
|) (
public FindClass: name  = (
	(*	jclass FindClass(JNIEnv *env, const char *name);

		In JDK release 1.1, this function loads a locally-defined class. It searches the directories and zip files specified by the CLASSPATH environment variable for the class with the specified name.

		Since Java 2 SDK release 1.2, the Java security model allows non-system classes to load and call native methods. FindClass locates the class loader associated with the current native method; that is, the class loader of the class that declared the native method. If the native method belongs to a system class, no class loader will be involved. Otherwise, the proper class loader will be invoked to load and link the named class.

		Since Java 2 SDK release 1.2, when FindClass is called through the Invocation Interface, there is no current native method or its associated class loader. In that case, the result of ClassLoader.getSystemClassLoader is used. This is the class loader the virtual machine creates for applications, and is able to locate classes listed in the java.class.path property.

		The name argument is a fully-qualified class name or an array type signature . For example, the fully-qualified class name for the java.lang.String class is:

		"java/lang/String"

		The array type signature of the array class java.lang.Object[] is:

		"[Ljava/lang/Object;"		*)

	| result = Alien new: 4. |
	api FindClass primFFICallResult: result with: env with: name.
	^safePointer: result
)
) : (
)
public class JavaVM withVmPtr: vmPointerAlien = (
(* Encapsulates standard vm methods. Function pointers provided by struct JNIInvokeInterface. *)|
	vm = vmPointerAlien.
	api = struct JNIInvokeInterface on: (Alien forPointer: (vmPointerAlien unsignedLongAt: 1)).
|) (
) : (
)
private class Structures = (||) (
public class JNIInvokeInterface on: anAlien = Struct on: anAlien (||) (
) : (
)
public class JNINativeInterface on: anAlien = Struct on: anAlien (||) (
public FindClass = (
	^Alien forPointer: (data unsignedLongAt: 25)
)
) : (
)
public class JavaVMInitArgs on: anAlien = Struct on: anAlien (
(*	typedef struct JavaVMInitArgs {
		jint version;
		jint nOptions;
    		JavaVMOption *options;
    		jboolean ignoreUnrecognized;
} JavaVMInitArgs;	*)||) (
public ignoreUnrecognized = ( ^data unsignedByteAt: 13 )
public ignoreUnrecognized: byte = ( data unsignedByteAt: 13 put: byte )
public nOptions = ( ^data signedLongAt: 5. )
public nOptions: integer = ( data signedLongAt: 5 put: integer )
public options = ( ^Alien forPointer: (data unsignedLongAt: 9) )
public options: pointerOrAddress = ( data unsignedLongAt: 9 put: pointerOrAddress )
public version = ( ^data signedLongAt: 1 )
public version: integer = ( data signedLongAt: 1 put: integer )
) : (
dataSize = (
	^13.
)
public newC = (
	^self on: (Alien newC: dataSize)
)
)
public class JavaVMOption on: anAlien = Struct on: anAlien (
(*	typedef struct JavaVMOption {
	char *optionString;
    	void *extraInfo;
	} JavaVMOption;	*)||) (
public extraInfo = ( ^Alien forPointer: (data unsignedLongAt: 5) )
public extraInfo: addressOrPointer = ( data unsignedLongAt: 5 put: addressOrPointer )
public optionString = ( ^Alien forPointer: (data unsignedLongAt: 1) )
public optionString: addressOrPointer = ( data unsignedLongAt: 1 put: addressOrPointer )
) : (
dataSize = (
	^8
)
public newC = (
	^self on: (Alien newC: (self dataSize))
)
)
class Struct on: anAlien = (
(* Normally, each struct should extend Alien, but NS does not (yet?) support variable-byte classes. *)|
	data = anAlien.
|) (
dataSize = (
	subclassResponsibility
)
public doesNotUnderstand: message = (
	^message sendTo: data
)
) : (
)
) : (
)
public CreateJavaVM: p_vm p_env: p_env vm_args: vm_args = (
	(*	jint JNI_CreateJavaVM(JavaVM **p_vm, void **p_env, void *vm_args);
		Loads and initializes a Java VM. The current thread becomes the main thread. Sets the env argument to the JNI interface pointer of the main thread.	*)

	| result |
	result:: Alien new: 4.
	(Alien lookup: 'JNI_CreateJavaVM' inLibrary: 'jvm.dll') primFFICallResult: result with: p_vm with: p_env with: vm_args.
	^result signedLongAt: 1
)
public def = (
	^definitions
)
public doesNotUnderstand: message = (
	(definitions respondsTo: (message selector)) ifTrue: [
		^message sendTo: definitions	
	].
	(structures respondsTo: (message selector)) ifTrue: [
		^message sendTo: structures
	].
	^super doesNotUnderstand: message
)
safePointer: addressOrPointer = (
	| address |
	address:: addressOrPointer unsignedLongAt: 1.
	^(address = 0) ifTrue: [nil] ifFalse: [Alien forPointer: address]
)
public struct = (
	^structures
)
) : (
)
